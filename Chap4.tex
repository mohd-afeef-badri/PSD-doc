\chapter{Tutorials}

\textbf{Preliminaries}\\
Before diving into the tutorials, here are some preliminaries that will help you guide easily through them.

\begin{itemize}
    \item A PSD simulation is performed in three steps: preprocessing, solving, and postprocessing. 
    \item Domain: denoted by $\Omega$ is a a $n$-dimensional solid body such that $\Omega \subset \mathbbm{R}^n$ with $n=2$   for 2D problems or  $n=3$ for 3D problems.
    \item Finite element mesh: denoted by $\Omega^h$ with mesh size $h$. Mesh can be triangular in 2D and tetrahedral in 3D.
    \item MPI processes for simulation: denoted by $\np$ these are the total MPI ranks that will work in parallel to solve the problem.
    \item Partitioned mesh: denoted by $\{ \Omega ^h_i \}_{i=1}^{\np}$ these are set of subdomains which are held by each MPI rank during a parallel simulation.
\end{itemize}

\section{Linear Elasticity}
Linear Elasticity is a mathematical approximation of solid object deformation caused by prescribed loading conditions. It is a simplification of the more general nonlinear theory of elasticity. PSD allows for solving Linear Elasticity problems both in sequential and in parallel. We shall discuss how to do so in details within this section.


PSD is a FEM based solver, to solve a given physics it heavily relies on the variational formulations of the underlying physics. Let us begin with writing the variational formulation of system of  Elasticity in which the primary unknown is the displacements vector $\bu=\{u_j\}^n_{j=1}$. In the Lagrangian FE framework for searching the unknown nodal displacements vector $\bu^h=\{u^h_j\}^n_{j=1}$ the variational formulation of system of  Elasticity reads,
%
%
\begin{equation}\label{Eq:Varf}
\forall i \in \llbracket 1; N_{\text p} \rrbracket,  \int_{\Omega^h_i}\sig(\buh) : \eps(\bvh) = \int_{\partial\Omega^h_{i,\text{N}}} \mathbf{f}\cdot\bvh \, \quad\forall\,\bvh\in\mathbb{V}^h,\buh\in\mathbb{V}^h,
\end{equation}
%
here,  $\buh$ is in fact the FE trial function and $\bvh=\{v^h_j\}^n_{j=1}$ is the FE test function.

\begin{equation}\label{Eq:LinearElasticity}
\forall i \in \llbracket 1; N_{\text p} \rrbracket, 
\int_{\Omega^h_i}\lambda\nabla\cdot\buh\nabla\cdot\bvh + \int_{\Omega^h_i}2\mu\boldsymbol\varepsilon(\buh):\boldsymbol\varepsilon(\bvh)-\int_{\Omega^h_i}\mathbf{f}\cdot\bvh=0, \quad\forall\bvh\in[H^1_0(\Omega^h_i)]^n 
\end{equation}

In these formulations $\lambda$ and $\mu$ are the Lame's parameters, $\mathbf{f}$ is the body force vector.  

\subsection{PSD simulation of bar problem bending under own body weight \label{sec:2d-bar-load}}

{
	\renewcommand{\subsection}{\subsubsection}
	\input{./tutorials/le-tutorial-1.tex}
}

\subsection{PSD simulation of of bar problem using a sequential solver (non parallel) \label{sec:2d-seq-load}}

{
	\renewcommand{\subsection}{\subsubsection}
	\input{./tutorials/le-tutorial-2.tex}
}



\subsection{PSD simulation of 2D bar problem clamped at both ends \label{sec:2D-bar-clamped1}}

{
	\renewcommand{\subsection}{\subsubsection}
	\input{./tutorials/le-tutorial-3.tex}
}


\subsection{PSD simulation of 2D bar problem clamped at one end wile being pulled at the other end (Dirichlet-Dirichlet case)\label{sec:2d-bar-clamped2}}

{
	\renewcommand{\subsection}{\subsubsection}
	\input{./tutorials/le-tutorial-4.tex}
}


\pagebreak


\subsection{PSD simulation of 2D bar problem clamped at one end wile being pulled at the other end (Dirichlet--Neumann case)\label{sec:2d-bar-clamped3}}

{
	\renewcommand{\subsection}{\subsubsection}
	\input{./tutorials/le-tutorial-5.tex}
}
 

\pagebreak




\subsection{PSD simulation of 2D bar problem clamped at one end wile being pulled at the other end (Dirichlet-Neumann-Point boundary conditions case)\label{sec:2d-bar-clamped4}}


{
	\renewcommand{\subsection}{\subsubsection}
	\input{./tutorials/le-tutorial-6.tex}
}



\pagebreak



\subsection{PSD simulation of 3D bar problem clamped at one end wile being pulled at the other end (Dirichlet-Neumann case)\label{sec:3d-bar-clamped3}}

{
	\renewcommand{\subsection}{\subsubsection}
	\input{./tutorials/le-tutorial-7.tex}
}

\pagebreak


\subsection{PSD simulation of 3D  mechanical piece (Dirichlet-Neumann case) with complex mesh\label{sec:3d-bar-clamped3-sub}}

{
	\renewcommand{\subsection}{\subsubsection}
	\input{./tutorials/le-tutorial-8.tex}
}
\pagebreak
\subsection{PSD linear elasticity tutorial using Mfront-PSD interface\label{sec:2d-mfront}}

{
\renewcommand{\subsection}{\subsubsection}
\input{./tutorials/le-tutorial-9.tex}
}


\subsection{Additional exercises on linear elasticity}
{
	\renewcommand{\subsection}{\subsubsection}
	\input{./tutorials/le-exercises.tex}
}


\pagebreak













\section{Damage mechanics}
\subsection{Hybrid phase-field for damage}
On a meshed domain $\Omega^h\in\Omega\subset\mathbb{R}^n$, for damage mechanics the mixed finite element variational formulation in the Lagrangian framework for searching the unknown nodal displacements vector $\bu^h=[u_1,u_2,u_3]^\mathsf{T}$ reads,
%
%
\begin{equation}\label{Eq:VarfU}
\begin{aligned}
&\text{search}~\buh\in\mathbb{V}^h \text{~that satisfies}~\forall\, t\in[0,T]:\\
&\int_{\Omega^h}\big[(1-d^h)^2 + \kappa \big]\sig(\buh) : \eps(\bvh) \,\dv= \int_{\partial\Omega^h_\text{N}} \overline{\bt}\cdot\bvh \,\ds \quad\forall\,\bv^h\in\mathbb{V}^h,
\end{aligned}
\end{equation}
where $\kappa\ll1$ is a model parameter to prevent numerical singularity when $d \to 1$.
 %
 %
In this formulation, the notation ``$:$'' is used for the double contraction between tensors (i.e., component-wise tensor product) and $ \mathbb{V}^h $ is a  mixed third order vector valued finite element functional space to approximate vector test function~$\bvh$ and vector trial function~$\buh$:
 %
\begin{equation}
\mathbb{V}^h=\left\{ \bu^h\in [ {H}^1(\Omega^h) ]^3~~\forall t\in[0,T]~|~ \forall \bx\in\partial\Omega^h_{\text{D}}~\buh=\overline{\bu}\right\},
\end{equation}
%
with ${H}^1(\Omega^h)$ denoting a square integrable Sobolev functional space.
Similarly, for~the phase-field the standard finite element variational formulation for the unknown damage scalar $\fih$ reads, 
%
%
\begin{equation}
\begin{aligned}\label{Eq:VarfPhi}
&\text{search}~\fih\in{{V}}^h \text{~that satisfies}~\forall\, t\in[0,T]:\\
&\int_{\Omega^h}\left[ \frac{\bgc}{l_0} + 2 \mathcal{H}^{+}(\buh) \right]\fih\ttah\, \dv + \int_{\Omega^h} {\bgc}{l_0}\nabla\fih \cdot \nabla\ttah \, \dv= \int_{\Omega^h} 2\mathcal{H}^{+}(\buh)\ttah \, \dv\quad\forall\,\ttah\in{{V}}^h, 
\end{aligned}
\end{equation}
%
%
where,~${{V}}^h$ denotes the scalar finite element functional space to approximate scalar test function~$\ttah$ and scalar trial function~$\fih$:
\begin{equation}
{{V}}^h=\left\{\fih \in  {H}^1(\Omega^h)~~\forall t\in[0,T]~\middle|~\fih\in[0,1]  \right\}.
\end{equation}


\subsection{Tensile cracking of a pre-cracked plate: A 2D example of PSD parallel solver}

A two dimensional test is introduced. The problem of interest is the typical single notch square plate cracking test under tensile loading. A unit square with a pre existing crack  is clamped at the bottom $u_1=u_2=0$ (first boundary condition) and is loaded quasi-statically $u_2=u_2 + \Delta u_2$ on its top surface till the crack propagates through its walls. So there are two Dirichlet conditions one on the top border and one on the bottom one.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.3\textwidth]{./Images/square-notch.png}
	\caption{Domain of the single notch square cracking problem under tensile loading. \label{bar-sd0}}
\end{figure}

To model this test PSD provides hybrid phase-field modelling  technique. We use ParaView post-processing of displacement $u$ and phase-field $d$ to visualise the cracking process. A PSD simulation is a two step process, with step one being the  \sh{ PSD\_PreProcess }:

\begin{lstlisting}[style=BashInputStyle]
	PSD_PreProcess -dimension 2 -problem damage -model hybrid_phase_field \
	-dirichletconditions 2 -postprocess ud
\end{lstlisting}

A note on flags. 

- This is a two-dimensional problem, so we use the flag  \sh{-dimension 2}.
- This problem indeed falls under the category of damage-mechanics, hence the flag \sh{ -problem damage}.
- We wish to solve this problem by invoking the hybrid phase-field problem, which is signified by the flag  \sh{ -model hybrid\_phase\_field}.
- Versed in the description above the problem contains two Dirichlet conditions, we signal this via the flag \sh{-dirichletconditions 2}. 
- Finally for this problem we use the flag  \sh{-postprocess ud}  which enables post-processing of displacement $u$ and damage (phase-field)  $d$ fields.

Once the step above has been performed, we solve the problem using four MPI processes, with the given mesh file \sh{tensile-crack.msh}. This is step two of the PSD simulation   \sh{ PSD\_Solve}.

\begin{lstlisting}[style=BashInputStyle]
	PSD_Solve -np 4 Main.edp -mesh ./../Meshes/2D/tensile-crack.msh -v 0
\end{lstlisting}

\begin{figure}[h!]
	\centering
	
	\includegraphics[width=0.24\textwidth]{./Images/u0.png}
	\includegraphics[width=0.24\textwidth]{./Images/u1.png} 
	\includegraphics[width=0.24\textwidth]{./Images/u2.png}
	\includegraphics[width=0.24\textwidth]{./Images/u3.png}\\
	\includegraphics[width=0.24\textwidth]{./Images/u4.png}
	\includegraphics[width=0.24\textwidth]{./Images/u5.png}
	\includegraphics[width=0.24\textwidth]{./Images/u6.png}
	\includegraphics[width=0.24\textwidth]{./Images/u7.png}
	\caption{Finite element displacement visualised for the 2D problem with ParaView at different timesteps (quasi-statics). Time progresses from left to right in a row and top to bottom when comparing rows. \label{u-fem}}
\end{figure}



\begin{figure}[h!]
	\centering
	
	\includegraphics[width=0.24\textwidth]{./Images/d0000.png}
	\includegraphics[width=0.24\textwidth]{./Images/d0010.png} 
	\includegraphics[width=0.24\textwidth]{./Images/d0020.png}
	\includegraphics[width=0.24\textwidth]{./Images/d0030.png}\\
	\includegraphics[width=0.24\textwidth]{./Images/d0040.png}
	\includegraphics[width=0.24\textwidth]{./Images/d0050.png}
	\includegraphics[width=0.24\textwidth]{./Images/d0060.png}
	\includegraphics[width=0.24\textwidth]{./Images/d0069.png}
	\caption{Finite element damage visualised for the 2D problem with ParaView at different timesteps (quasi-statics). Time progresses from left to right in a row and top to bottom when comparing rows. \label{d-fem}}
\end{figure}

Figures \ref{u-fem} and \ref{d-fem} present the finite element displacement and damage field, which enable us to visualise the cracking of the square plate.



\begin{figure}[h!]
	\centering
	
	\includegraphics[width=0.6\textwidth]{./Images/terminal1.png}
	\caption{Applied traction, non-linear iterations to convergence, and residual being casted onto the terminal shell. \label{term}}
\end{figure}

While this test runs, you will see on your screen the amount of traction updated, non-linear iterations taken to converge per-quasi-time-step and residue of $u$ and $d$. See figure \ref{term} that shows the screenshot of the terminal while the test was running.  In order to construct your own test case try editing the  \sh{ControlParameters.edp} file   







\subsection{Tensile cracking of a pre-cracked cube: A 3D example of PSD parallel solver}

A three-dimensional test synonymous to its two-dimensional counterpart introduced above is used here as an tutorial example.   The problem of interest is now a unit extrusion (along $z$-axis) of the 2D case above. Cracking is initiated and propagated under tensile loading. The unit cube with its  pre existing crack  is clamped at the bottom $u_1=u_2=u_3=0$ (first boundary condition) and is loaded quasi-statically $u_2=u_2 + \Delta u_2$ on its top surface till the crack propagates through its walls. So there are two Dirichlet conditions one on the top border and one on the bottom one.

Just like in the 2D case, to model this test PSD's' hybrid phase-field modelling  technique is used. We will again use ParaView post-processing of displacement $u$ and phase-field $d$ to visualise the cracking process. A PSD simulation is a two step process, with step one being the  \sh{ PSD\_PreProcess }:

\begin{lstlisting}[style=BashInputStyle]
	PSD_PreProcess -dimension 3 -problem damage -model hybrid_phase_field  \
	-dirichletconditions 2 -postprocess ud 
\end{lstlisting}

Notice that the flags used here are almost similar except for the   \sh{ -dimension 3 } flag, which indeed specifies three-dimensional problem.

Once the step above has been performed, we solve the problem using four MPI processes, with the given mesh file \sh{tensile-crack.msh}. This is step two of the PSD simulation   \sh{ PSD\_Solve}.

\begin{lstlisting}[style=BashInputStyle]
	PSD_Solve -np 3 Main.edp -mesh ./../Meshes/3D/tensile-crack.msh -v 0
\end{lstlisting}

\begin{figure}[h!]
	\centering
	
	\includegraphics[width=0.24\textwidth]{./Images/u3d0.png}
	\includegraphics[width=0.24\textwidth]{./Images/u3d1.png} 
	\includegraphics[width=0.24\textwidth]{./Images/u3d2.png}
	\includegraphics[width=0.24\textwidth]{./Images/u3d3.png}
	\caption{Finite element displacement visualised for the 3D problem with ParaView at different timesteps (quasi-statics). Time progresses from left to right in a row and top to bottom when comparing rows. \label{u3d-fem}}
\end{figure}



\begin{figure}[h!]
	\centering
	
	\includegraphics[width=0.24\textwidth]{./Images/d3d0.png}
	\includegraphics[width=0.24\textwidth]{./Images/d3d1.png} 
	\includegraphics[width=0.24\textwidth]{./Images/d3d2.png}
	\includegraphics[width=0.24\textwidth]{./Images/d3d3.png}
	\caption{Finite element damage visualised for the 3D problem with ParaView at different timesteps (quasi-statics). Time progresses from left to right in a row and top to bottom when comparing rows. \label{d3d-fem}}
\end{figure}

Figures \ref{u3d-fem} and \ref{d3d-fem} present the finite element displacement and damage field of the 3D problem, which enable us to visualise the cracking of the cubic specimen.

\subsection{Parallel 2D tensile cracking and calculate-ploting reaction-force}

In solid mechanics often the quantities of interest includes plots such as reaction-force on a surface vs. the applied force. Often times these are experimental outputs and are used for validation. 

PSD provides routines to calculate the reaction force on a surface and also provides means of live plotting (run-time)  of these results. Imagine the test case of tensile cracking of plate (2D) as discussed above. Considering we are now interested in seeing the plot of reaction force at surface vs. the applied tensile displacement, we would need to use two extra flags in the   \sh{ PSD\_PreProcess} step. These flags are \sh{-getreactionforce} and \sh{ -reactionforce  stress\_based } as read below:

\begin{lstlisting}[style=BashInputStyle]
	PSD_PreProcess -dimension 2 -problem damage -model hybrid_phase_field \
	-dirichletconditions 2 -getreactionforce -reactionforce stress_based
\end{lstlisting}

The flag  \sh{-getreactionforce} directs PSD to include the routines to get the reaction force and  \sh{ -reactionforce  stress\_based } is the method by which we get reaction force, in this case reaction force is calculated using integral of stress in $y$ direction $F_y=\int_{\partial\Omega_{top}} \sigma_y$. Other method \sh{ -reactionforce variational\_based} also exists within PSD, which is more accurate but slower, this method calculates reaction force based on matrix vector multiplication ${F_x,F_y}=\mathbf{A}{u_1,u_2}$ .

Run the problem in the usual way bu using \sh{ PSD\_Solve} and appropriate number of processes and mesh.  While the PSD solver runs it will create a file \sh{ force.data} that contains the reaction force and the applied traction. 

\begin{lstlisting}[style=BashInputStyle]
	PSD_Solve -np 4 Main.edp -mesh ./../Meshes/2D/tensile-crack.msh -v 0
\end{lstlisting}

You can then go ahead and plot \sh{ force.data} to see how $F_y$ and $F_x$  evolve  with $\Delta u_2$. Within the file the first column is the loading $\Delta u_2$, the second and the third columns are the forces $F_x$ and $F_y$.



\begin{figure}[h!]
	\centering
	
	\includegraphics[width=0.4\textwidth]{./Images/plot-fd.png}
	\caption{Applied traction vs. force in y direction. \label{fd-plot}}
\end{figure}

Optionally if you have GnuPlot configured with PSD you can see live ploting of this curve if you use option  \sh{-plotreactionforce} during the  \sh{ PSD\_PreProcess}. 

\begin{figure}[h!]
	\centering
	
	\includegraphics[width=0.3\textwidth]{./Images/gp0.png}\includegraphics[width=0.3\textwidth]{./Images/gp1.png}\includegraphics[width=0.3\textwidth]{./Images/gp2.png}
	\caption{Applied traction vs. force in y direction plotted live using PSD. \label{gnuplot-plot}}
\end{figure}



\subsection{Parallel 3D and calculate reactionforce}


\begin{lstlisting}[style=BashInputStyle]
	PSD_PreProcess -dimension 3 -problem damage -model hybrid_phase_field \
	-dirichletconditions 2 -getreactionforce -reactionforce stress_based
\end{lstlisting}

\begin{lstlisting}[style=BashInputStyle]
	PSD_Solve -np 3 Main.edp -mesh ./../Meshes/3D/tensile-crack.msh -v 0
\end{lstlisting}



\subsection{L-shape cracking with point loading}
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.3\textwidth]{./Images/fm-geometry.png}
	\caption{Geometry of the L-shaped test used in this tutorial. \label{L-shape-geo}}
\end{figure}

\subsubsection{Preprocessing}

You can either solver the problem using vectorial approach (recommended) or using staggered approach. To generate the solver use either from below.

\textbf{Generation of solver (vectorial)}

\begin{lstlisting}[style=BashInputStyle]
	PSD_PreProcess -dimension 2 -problem damage -model hybrid_phase_field \
	-dirichletconditions 1 -dirichletpointconditions 1 -debug -postprocess ud \
	-energydecomp -constrainHPF -vectorial -getreactionforce -plotreactionforce \
	-reactionforce variational_based
\end{lstlisting}

\textbf{Generating solver (staggered)}

\begin{lstlisting}[style=BashInputStyle]
	PSD_PreProcess -dimension 2 -problem damage -model hybrid_phase_field \
	-dirichletconditions 1 -dirichletpointconditions 1 -debug -postprocess ud \
	-energydecomp -constrainHPF -getreactionforce -plotreactionforce \
	-reactionforce variational_based
\end{lstlisting}


\subsubsection{Edit Cycle}

\textbf{Edit ControlParameter.edp:}

\begin{itemize}
	
	\item Update physical parameter, change
	
	\begin{lstlisting}[style=CppStyle]
		real lambda = 121.15e3 ,
		mu     = 80.77e3  ,
		Gc     = 2.7      ; 
	\end{lstlisting}
	
	to
	
	\begin{lstlisting}[style=CppStyle]
		real lambda = 6.16e3 ,
		mu     = 10.95e3 ,
		Gc     = 8.9e-2  ;
	\end{lstlisting}
	
	\item Update solver parameter , change
	
	\begin{lstlisting}[style=CppStyle]
		real lfac  = 2.0  ,
		maxtr = 7e-3 ,
		tr    = 1e-5 ,
		dtr   = 1e-5 ,
		lo           ; 
	\end{lstlisting}
	
	to
	
	\begin{lstlisting}[style=CppStyle]
		real lfac  = 2.0  ,
		maxtr = 1    ,
		tr    = 1e-2 ,
		dtr   = 1e-2 ,
		lo           ; 
	\end{lstlisting}
	
	
	\item Enter the correct Point boundary condition, change
	
	\begin{lstlisting}[style=CppStyle]
		real[int,int] PbcCord = [
		//-------------------- [  x  , y  ] --------------------//
		[  0. , 0. ]    // point 0                       
		//------------------------------------------------------//
		];
		
		macro Pbc0Ux  -0. //
		macro Pbc0Uy  -0. //
	\end{lstlisting}
	
	to 
	
	\begin{lstlisting}[style=CppStyle]
		real[int,int] PbcCord = [
		//-------------------- [  x  , y  ] --------------------//
		[  470., 250. ]    // point 0                       
		//------------------------------------------------------//
		]
		;
		macro Pbc0Uy  tr //
	\end{lstlisting}
	
\end{itemize}


\textbf{Edit LinearFormBuilderAndSolver.edp:}

\begin{itemize}
	
	\item To postprocess correct reaction forces in LinearFormBuilderAndSolver.edp for vectorial solver, change
	
	\begin{lstlisting}[style=CppStyle]
		for(int i=0; i < Th.nv; i++){
			if(abs(Th(i).y-1.)<.000001){
				forcetotx = forcetotx + F[][i*3]*DP[i*3];           
				forcetoty = forcetoty + F[][i*3+1]*DP[i*3+1];       
			}
		} 
	\end{lstlisting}
	
	to
	
	\begin{lstlisting}[style=CppStyle]
		if(mpirank==mpirankPCi[0]){
			forcetotx = forcetotx + F[][PCi[0]*3+0]*DP[PCi[0]*3+0];
			forcetoty = forcetoty + F[][PCi[0]*3+1]*DP[PCi[0]*3+1]; 
		} 
	\end{lstlisting}
	
	\item To postprocess correct reaction forces in LinearFormBuilderAndSolver.edp for staggered solver, change
	
	\begin{lstlisting}[style=CppStyle]
		for(int i=0; i < Th.nv; i++){
			if(abs(Th(i).y-1.)<.000001){
				forcetotx = forcetotx + F[][i*2]*DP[i*2];           
				forcetoty = forcetoty + F[][i*2+1]*DP[i*2+1];       
			}
		}
	\end{lstlisting}
	
	to
	
	\begin{lstlisting}[style=CppStyle]
		if(mpirank==mpirankPCi[0]){
			forcetotx = forcetotx + F[][PCi[0]*2+0]*DP[PCi[0]*2+0];
			forcetoty = forcetoty + F[][PCi[0]*2+1]*DP[PCi[0]*2+1]; 
		} 
	\end{lstlisting}
	
	\item Finally to include cyclic loading, change
	
	\begin{lstlisting}[style=CppStyle]
		//-----------------updating traction----------------//
		
		tr += dtr; 
	\end{lstlisting}
	
	
	to
	
	\begin{lstlisting}[style=CppStyle]
		//-----------------updating traction----------------//
		
		if(iterout<50)
		tr += dtr;
		if(iterout>=51 && iterout<110) 
		tr -= dtr; 
		if(iterout>=111)
		tr += dtr; 
	\end{lstlisting}
	
	\begin{figure}[h!]
		\centering
		\includegraphics[width=0.3\textwidth]{./Images/fm-mesh.png}
		\caption{Finite element mesh of the L-shaped test. \label{L-shape-mesh}}
	\end{figure}
	
\end{itemize}


\subsection{Solving}

Irrespective of weather vectorial or staggered mode is used solve the problem using \sh{PSD\_Solve}

\begin{lstlisting}[style=BashInputStyle]
	PSD_Solve -np 4 Main.edp -wg -v 0 -mesh ./../Meshes/2D/L-shaped-crack.msh
\end{lstlisting}

\subsubsection{Postprocessing}

Use ParaView to post process results. 


\begin{figure}[h!]
	\centering
	\includegraphics[width=0.3\textwidth]{./Images/fm-d1.png}
	\includegraphics[width=0.3\textwidth]{./Images/fm-d2.png}
	\includegraphics[width=0.3\textwidth]{./Images/fm-d3.png}
	\caption{Finite element solution showing: Crack initiation,  movement, and  development. \label{L-shape-mesh-crack}}
\end{figure}

On you screen, the force displacement curve which plots \sh{force.data} should look something like this

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.5\textwidth]{./Images/fm-force-displacement.png}
	\caption{Force-displacement curve with cyclic loading. \label{L-shape-fd-curve}}
\end{figure}

\subsection{Exercise 1}

Optionally try changing \sh{-reactionforce stress\_based} to \sh{-reactionforce variational\_based} for changing the method to extract reaction force, note that stress based method is way faster.

\subsection{Exercise 2}

Optionally try using  \sh{-useGFP} flag with \sh{PSD\_PreProcess} optimized solver

\subsection{Exercise 3}

Add \sh{-sequential} flag to \sh{PSD\_PreProcess} for sequential solver, but remember to use \sh{PSD\_Solve\_Seq} instead of \sh{PSD\_Solve}

\subsection{Advanced Exercise 1}
try the \sh{-vectorial} flag for vectorial finite element method

\subsection{Advanced Exercise 2}
try the \sh{-energydecomp} flag for using split of tensile energy

\subsection{Advanced Exercise 3}
try using \sh{-constrainHPF} flag for using the constrain condition in hybrid phase field model

\pagebreak

\section{Elastodynamics}

\subsection{Parallel 2D}

The problem of interest is a single Dirichlet condition (clamped end bar) and traction loading. For this example we use Newmark-$\beta$ time discretization. Additionally postrocessing is demanded for displacement, acceleration, and velocity ($u,a,v$). 

\begin{lstlisting}[style=BashInputStyle]
	PSD_PreProcess -dimension 2 -problem elastodynamics -dirichletconditions 1 -tractionconditions 1 \
	-timediscretization newmark_beta -postprocess uav
\end{lstlisting}

Once the step above has been performed, we solve the problem using two MPI processes, with the given mesh file \sh{bar-dynamic.msh}. 

\begin{lstlisting}[style=BashInputStyle]
	PSD_Solve -np 2 Main.edp -mesh ./../Meshes/2D/bar-dynamic.msh -v 0
\end{lstlisting}

\begin{figure}[h!]
	\includegraphics[width=0.19\textwidth]{./Images/ed-u0.png}
	\includegraphics[width=0.19\textwidth]{./Images/ed-u2.png}
	\includegraphics[width=0.19\textwidth]{./Images/ed-u3.png}
	\includegraphics[width=0.19\textwidth]{./Images/ed-u4.png}
	\includegraphics[width=0.19\textwidth]{./Images/ed-u5.png}
	\caption{Finite element displacement field on warped mesh shown at different time steps. \label{bar-ed}}
\end{figure}

Using ParaView for postprocessing the results that are provided in the \sh{VTUs...} folder, results such as those shown in figure~\ref{bar-ed} can be extracted. 

\subsection{Parallel 3D}

The problem of interest is a single Dirichlet condition (clamped end bar) and traction loading. For this example we use Newmark-$\beta$ time discretization. Additionally postrocessing is demanded for displacement, acceleration, and velocity ($u,a,v$). 

\begin{lstlisting}[style=BashInputStyle]
	PSD_PreProcess -dimension 3 -problem elastodynamics -dirichletconditions 1 -tractionconditions 1 \
	-timediscretization newmark_beta
\end{lstlisting}

Once the step above has been performed, we solve the problem using four MPI processes, with the given mesh file \sh{bar-dynamic.msh}. 

\begin{lstlisting}[style=BashInputStyle]
	PSD_Solve -np 4 Main.edp -mesh ./../Meshes/3D/bar-dynamic.msh -v 0
\end{lstlisting}


\subsection{Sequential problems}

To the same problems above Add \sh{-sequential} flag to \sh{PSD\_PreProcess} for sequential solver, but remember to use \sh{PSD\_Solve\_Seq} instead of \sh{PSD\_Solve}. So the work flow for the 2D problem would be:

\begin{lstlisting}[style=BashInputStyle]
	PSD_PreProcess -dimension 2 -problem elastodynamics -dirichletconditions 1 -tractionconditions 1 \
	-timediscretization newmark_beta -postprocess uav -sequential
\end{lstlisting}

Once the step above has been performed, we solve the problem using the given mesh file \sh{bar-dynamic.msh}. 

\begin{lstlisting}[style=BashInputStyle]
	PSD_Solve_Seq -np 2 Main.edp -mesh ./../Meshes/2D/bar-dynamic.msh -v 0
\end{lstlisting}

Similarly try out the 3D problem as well.

\subsection{Different time discretization}

PSD offers different time discretization techniques for solving time dependent problems. For this example instead of using Newmark-$\beta$ time  discretization let us switch to more advanced Generalized-$\alpha$ one. This can be done by \sh{-timediscretization generalized\_alpha}, so for example for a 2D problem we use:

\begin{lstlisting}[style=BashInputStyle]
	PSD_PreProcess -dimension 2 -problem elastodynamics -dirichletconditions 1 -tractionconditions 1 \
	-timediscretization generalized_alpha -postprocess uav
\end{lstlisting}

Once the step above has been performed, we solve the problem using three MPI processes, with the given mesh file \sh{bar-dynamic.msh}. 

\begin{lstlisting}[style=BashInputStyle]
	PSD_Solve -np 3 Main.edp -mesh ./../Meshes/2D/bar-dynamic.msh -v 0
\end{lstlisting}

Similarly try out the 3D problem as well.

\subsection{Comparing CPU time}

PSD provides mean to time log your solver via \sh{-timelog} flag. What this will do when you run your solver, on the terminal you will have information printed on what is the amount of time taken by each step of your solver. Warning, this will make your solver slower, as this action involves MPIbarrier routines for correctly timing operation. 

An example work flow of 2D solver with timelogging:

\begin{lstlisting}[style=BashInputStyle]
	PSD_PreProcess -dimension 2 -problem elastodynamics -dirichletconditions 1 -tractionconditions 1 \
	-timediscretization newmark_beta -postprocess uav -timelog
\end{lstlisting}

Once the step above has been performed, we solve the problem using two MPI processes, with the given mesh file \sh{bar-dynamic.msh}. 

\begin{lstlisting}[style=BashInputStyle]
	PSD_Solve -np 2 Main.edp -mesh ./../Meshes/2D/bar-dynamic.msh -v 0
\end{lstlisting}


\begin{figure}[h!]
	\centering
	\includegraphics[width=0.4\textwidth]{./Images/ed-time-par.png}
	\caption{Time logging output produced for parallel run on 2 processes.\label{time-par-ed}}
\end{figure}

The figure~\ref{time-par-ed} shows the time logging output produced for parallel run on 2 processes using \sh{-timelog} flag. Similar output is produced for sequential solver of the same problem shown in figure~\ref{time-seq-ed}. Take note of the speed up, which should be two folds - parallel solver solves the full problem in half the time (1.5 sec) than that of sequential solver (3.3 sec). This is due to the fact we used 2 MPI processes.

Also take note of timings produced for different operations of the solver. Note that in figures~\ref{time-par-ed}, \ref{time-seq-ed}, we only see the final time step of the solved problem. 

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.4\textwidth]{./Images/ed-time-seq.png}
	\caption{Time logging output produced for parallel run on 2 processes.\label{time-seq-ed}}
\end{figure}

\subsection{Exercise 1}

You are encouraged to try out timelogging and find out if the code (parallel/sequential) is any faster when we use Newmark-$\beta$ or Generalized-$\alpha$. Read the documentation for other types of time discretizations that can be performed with PSD, try each one out with \sh{-timelog} and compare. 

\subsection{Exercise  2}

There is a solver run level flag for mesh refinement \footnote{Mesh refinement is performed after partitioning.}. This flag is called \sh{-split [int]} which splits the triangles (resp. tetrahedrons) of your mesh into  four smaller  triangles (resp. tetrahedrons). As such \sh{-split 2} will produce a mesh with 4 times the elements of the input mesh. Similarly, \sh{-split n} where $n$ is a positive integer produces $2^n$ times more elements than the input mesh. You are encouraged to use this \sh{-split} flag to produce refined meshes and check, mesh convergence of a problem, computational time, etc. Use of parallel computing is recommended. You could try it out with \sh{PSD\_Solve} or \sh{PSD\_Solve\_Seq}, for example:

\begin{lstlisting}[style=BashInputStyle]
	PSD_Solve -np 2 Main.edp -mesh ./../Meshes/2D/bar-dynamic.msh -v 0 -split 2
\end{lstlisting}

for splitting each triangle of the mesh  \sh{bar-dynamic.msh} into 4. 


\subsection{Exercise  3}

There is a preprocess level flag \sh{-debug}, which as the name suggests should be used for debug proposes by developers. However, this flag will activate OpebGL live plotting of the problem, with displaced mesh. You are encouraged to try it out 

\begin{lstlisting}[style=BashInputStyle]
	PSD_PreProcess -dimension 2 -problem elastodynamics -dirichletconditions 1 -tractionconditions 1 \
	-timediscretization newmark_beta -postprocess uav -timelog -debug
\end{lstlisting}

Then to run the problem we need aditional \sh{-wg} flag

\begin{lstlisting}[style=BashInputStyle]
	PSD_Solve -np 2 Main.edp -mesh ./../Meshes/2D/bar-dynamic.msh -v 0 -wg
\end{lstlisting}

\subsection{Exercise  4}

PSD comes with additional set of plugins/functions that are highly optimized for performing certain operations during solving. These operations are handled by GoFast Plugins (GFP) kernel of PSD (optimize C++ classes/templates/structures), by default this functionality is turned off and not used. You are encouraged to try out using GFP functions in a solver by using \sh{-useGFP} flag flag to \sh{PSD\_PreProcess} For example, the PSD solver workflow for the first 2D example in this tutorial would be:

\begin{lstlisting}[style=BashInputStyle]
	PSD_PreProcess -dimension 2 -problem elastodynamics -dirichletconditions 1 -tractionconditions 1 \
	-timediscretization newmark_beta -postprocess uav -useGFP
\end{lstlisting}

Once the step above has been performed, we solve the problem using, with the given mesh file \sh{bar-dynamic}. 

\begin{lstlisting}[style=BashInputStyle]
	PSD_Solve -np 2 Main.edp -mesh ./../Meshes/2D/bar-dynamic.msh -v 0 -wg
\end{lstlisting}

Try it out for other problems of this tutorial. \sh{-useGFP} should lead to a faster solver, it might be a good idea to always use this option. To go one step further, use \sh{-timelog} flag and determine if you have some speed up.


\pagebreak

\section{Soil dynamics}

\subsection{Parallel 2D}

The problem of interest is a single Dirichlet condition problem of soildynamics in 2D. For this problem we use Newmark-$\beta$ time discretization. Additionally postrocessing is demanded for displacement, acceleration, and velocity ($u,a,v$).

\begin{lstlisting}[style=BashInputStyle]
	PSD_PreProcess -dimension 2 -problem soildynamics -dirichletconditions 1 -timediscretization newmark_beta \
	-postprocess uav
\end{lstlisting}

Once the step above has been performed, we solve the problem using four MPI processes, with the given mesh file \sh{soil.msh}. 

\begin{lstlisting}[style=BashInputStyle]
	PSD_Solve -np 4 Main.edp -mesh ./../Meshes/2D/soil.msh -v 0
\end{lstlisting}


\begin{figure}[h!]
	\centering
	\includegraphics[width=0.4\textwidth]{./Images/sd-u0.png}
	\includegraphics[width=0.4\textwidth]{./Images/sd-u1.png}\\
	\includegraphics[width=0.4\textwidth]{./Images/sd-u2.png}
	\includegraphics[width=0.4\textwidth]{./Images/sd-u3.png}\\
	\includegraphics[width=0.4\textwidth]{./Images/sd-u4.png}
	\caption{Finite element displacement and velocity fields visualized for the 2D problem with ParaView at different timesteps. \label{bar-sd}}
\end{figure}

Using ParaView for postprocessing the results that are provided in the \sh{VTUs...} folder, results such as those shown in figure~\ref{bar-sd} can be extracted.


\subsection{Parallel 3D}

The problem of interest is a single Dirichlet condition problem of soildynamics in 3D. For this problem we use Newmark-$\beta$ time discretization. Additionally postrocessing is demanded for displacement, acceleration, and velocity ($u,a,v$).

\begin{lstlisting}[style=BashInputStyle]
	PSD_PreProcess -dimension 3 -problem soildynamics -dirichletconditions 1 -timediscretization newmark_beta \
	-postprocess uav
\end{lstlisting}

Once the step above has been performed, we solve the problem using three MPI processes, with the given mesh file \sh{soil.msh}. 

\begin{lstlisting}[style=BashInputStyle]
	PSD_Solve -np 3 Main.edp -mesh ./../Meshes/3D/soil.msh -v 0
\end{lstlisting}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.4\textwidth]{./Images/sd-3du0.png}
	\includegraphics[width=0.4\textwidth]{./Images/sd-3du1.png}\\
	\includegraphics[width=0.4\textwidth]{./Images/sd-3du2.png}
	\includegraphics[width=0.4\textwidth]{./Images/sd-3du3.png}\\
	\includegraphics[width=0.4\textwidth]{./Images/sd-3du4.png}
	\caption{Finite element displacement and velocity fields visualized for the 3D problem with ParaView at different timesteps. \label{bar3d-sd}}
\end{figure}

Using ParaView for postprocessing the results that are provided in the \sh{VTUs...} folder, results such as those shown in figure~\ref{bar3d-sd} can be extracted.

\subsection{Parallel 2D with double couple}

In the 2D problem above seismic sources was supplied on the border, in the current one the source is more realistic and comes from a double couple (point Dirichlet condition). The double couple boundary condition is a way to impose moments caused by faults that create earthquakes, here in this problem double couple is imposed using displacement based. 

\begin{lstlisting}[style=BashInputStyle]
	PSD_PreProcess -dimension 2 -problem soildynamics -model linear -timediscretization newmark-beta \
	-useGFP -doublecouple displacement-based -postprocess uav
\end{lstlisting}

Once the step above has been performed, we solve the problem using two MPI processes, with the given mesh file \sh{soil-dc.msh}. 

\begin{lstlisting}[style=BashInputStyle]
	PSD_Solve -np 2 Main.edp -v 1 -ns -nw -mesh ./../Meshes/2D/soil-dc.msh
\end{lstlisting}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.45\textwidth]{./Images/sd-2ddcu0.png}
	\includegraphics[width=0.45\textwidth]{./Images/sd-2ddcu1.png}\\
	\includegraphics[width=0.45\textwidth]{./Images/sd-2ddcu2.png}
	\caption{Finite element displacement and acceleration fields visualized for the 2D problem with ParaView at different timesteps. \label{bar2ddc-sd}}
\end{figure}

Using ParaView for postprocessing the results that are provided in the \sh{VTUs...} folder, results such as those shown in figure~\ref{bar2ddc-sd} can be extracted.

Similarly try out the 3D problem. However take note that a the mesh \sh{./../Meshes/2D/soil-dc.msh} is not provided, so you will have to create your own mesh. 


\subsection{Parallel 3D with top-ii-vol meshing}

Single Dirichlet at the bottom and using GFP.

\begin{lstlisting}[style=BashInputStyle]
	PSD_PreProcess -dimension 3 -problem soildynamics -model linear -timediscretization newmark_beta \
	-useGFP -top2vol-meshing -timediscretization newmark-beta -postprocess uav
\end{lstlisting}

\begin{lstlisting}[style=BashInputStyle]
	PSD_Solve -np 4 Main.edp -v 0 -ns -nw 
\end{lstlisting}


\subsection{Parallel 3D with top-ii-vol meshing and double couple source}

Single Dirichlet via double couple and using GFP. Double couple is displacement based. 

\begin{lstlisting}[style=BashInputStyle]
	PSD_PreProcess -dimension 3 -problem soildynamics -model linear -timediscretization newmark_beta \
	-useGFP -top2vol-meshing -doublecouple displacement-based -postprocess uav
\end{lstlisting}

\begin{lstlisting}[style=BashInputStyle]
	PSD_Solve -np 3 Main.edp -v 0 -ns -nw 
\end{lstlisting}

\subsection{Exercise  1}

You are encouraged to try out sequential PSD solver, to do so used add \sh{-sequential} flag to \sh{PSD\_PreProcess} step and run the solver with \sh{PSD\_Solve\_Seq} instead of \sh{PSD\_Solve}. For example, the PSD sequential solver workflow for the first 2D example in this tutorial would be:

\begin{lstlisting}[style=BashInputStyle]
	PSD_PreProcess -dimension 2 -problem soildynamics -dirichletconditions 1 -timediscretization newmark_beta \
	-postprocess uav -sequential
\end{lstlisting}

Once the step above has been performed, we solve the problem using \sh{PSD\_Solve\_Seq}, with the given mesh file \sh{soil.msh}. 

\begin{lstlisting}[style=BashInputStyle]
	PSD_Solve_Seq  Main.edp -mesh ./../Meshes/2D/soil.msh -v 0
\end{lstlisting}

Try it out for other problems of this tutorial. 

\subsection{Exercise 2}

For soildynamic problems with double couple source, the double couple source can be introduced into the solver either by displacement-based operator -- providing displacements at the double couple points that will be converted to moments -- or by force-based operators -- providing forces at the double couple points that  will be converted to moments. In the tutorials above we already tried displacement-based way of introducing double couple source by using \sh{-doublecouple displacement\_based}. You are encouraged to try out the force-based double couple source by using \sh{-doublecouple force\_based}.

\subsection{Exercise 3}

You are encouraged to try out timelogging and find out if the code (parallel/sequential) is any faster when we use Newmark-$\beta$ or Generalized-$\alpha$. Read the documentation for other types of time discretizations that can be performed with PSD, try each one out with \sh{-timelog} and compare.

\subsection{Exercise  4}

PSD comes with additional set of plugins/functions that are highly optimized for performing certain operations during solving. These operations are handled by GoFast Plugins (GFP) kernel of PSD (optimize C++ classes/templates/structures), by default this functionality is turned off and not used. You are encouraged to try out using GFP functions in a solver by using \sh{-useGFP} flag flag to \sh{PSD\_PreProcess} For example, the PSD solver workflow for the first 2D example in this tutorial would be:

\begin{lstlisting}[style=BashInputStyle]
	PSD_PreProcess -dimension 2 -problem soildynamics -dirichletconditions 1 -timediscretization newmark\_beta \
	-postprocess uav -useGFP
\end{lstlisting}

Once the step above has been performed, we solve the problem using, with the given mesh file \sh{soil.msh}. 

\begin{lstlisting}[style=BashInputStyle]
	PSD_Solve -np 4 Main.edp -mesh ./../Meshes/2D/soil.msh -v 0
\end{lstlisting}

Try it out for other problems of this tutorial. \sh{-useGFP} should lead to a faster solver, it might be a good idea to always use this option. To go one step further, use \sh{-timelog} flag and determine if you have some speed up. 



\pagebreak

\section{General list of examples: Linear Elasticity}
 *============================================================*\\
  \textbf{Sequential  2D linear-elasticity}\\                   
 *============================================================*\\
\begin{lstlisting}[style=BashInputStyle] 
PSD_PreProcess -dimension 2 -bodyforceconditions 1 conditions 1 -sequential -dirichletconditions 1 
	
PSD_Solve_Seq Main.edp -v 0 -ns -nw 
\end{lstlisting}


*============================================================*\\
 \textbf{Sequential  3D linear-elasticity}                   \\
*============================================================*\\
\begin{lstlisting}[style=BashInputStyle] 
PSD_PreProcess -dimension 3 -bodyforceconditions 1 -sequential -dirichletconditions 1

PSD_Solve_Seq Main.edp -v 0 -ns -nw
\end{lstlisting}


*============================================================*\\
\textbf{ Sequential  2D linear-elasticity fastmethod }      \\
*============================================================*\\
\begin{lstlisting}[style=BashInputStyle] 
PSD_PreProcess -dimension 2 -bodyforceconditions 1 -sequential -dirichletconditions 1 -fastmethod 

PSD_Solve_Seq Main.edp -v 0 -ns -nw	
\end{lstlisting}
*============================================================*\\
\textbf{ Sequential  3D linear-elasticity   fastmethod }     \\
*============================================================*\\
\begin{lstlisting}[style=BashInputStyle] 
PSD_PreProcess -dimension 3 -bodyforceconditions 1 -sequential -dirichletconditions 1 -fastmethod 

PSD_Solve_Seq Main.edp -v 0 -ns -nw  	
\end{lstlisting}



*============================================================*\\
\textbf{ Parallel 2D linear-elasticity }                  \\
*============================================================*\\
	
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 2 -bodyforceconditions 1  -dirichletconditions 1 

ff-mpirun-np 2  Main.edp -v 0 -ns -nw
\end{lstlisting}
*============================================================\\
\textbf{ Parallel 3D linear-elasticity  }                 \\
*============================================================\\
	
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 3 -bodyforceconditions 1  -dirichletconditions 1 

ff-mpirun-np 2  Main.edp -v 0 -ns -nw
\end{lstlisting}
*============================================================\\
\textbf{ Parallel 2D linear-elasticity     fastmethod  }            \\
*============================================================\\
	
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 2 -bodyforceconditions 1  -dirichletconditions 1 -fastmethod  

ff-mpirun-np 2  Main.edp -v 0 -ns -nw	
\end{lstlisting}
*============================================================\\
\textbf{ Parallel 3D linear-elasticity     fastmethod }             \\
*============================================================\\
	
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 3 -bodyforceconditions 1  -dirichletconditions 1 -fastmethod  

ff-mpirun-np 2  Main.edp -v 0 -ns -nw
\end{lstlisting}

\section{General list of examples: Fracture mechanics}

*============================================================\\
\textbf{ Sequential  2D phase-field fracture mechanics }\\
*============================================================\\
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 2 -problem damage -model hybrid-phase-field -sequential -dirichletconditions 2   

PSD_Solve Main.edp -v 0 -ns -nw   
\end{lstlisting}
*============================================================\\
\textbf{ Sequential  3D phase-field fracture mechanics}\\ 
*============================================================\\

\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 3 -problem damage -model hybrid-phase-field -sequential -dirichletconditions 2   

PSD_Solve Main.edp -v 0 -ns -nw   
\end{lstlisting}
*============================================================\\
\textbf{ Parallel 2D phase-field fracture mechanics} \\
*============================================================\\

\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 2 -problem damage -model hybrid-phase-field -dirichletconditions 2   

PSD_Solve -np 2  Main.edp -v 0 -ns -nw   
\end{lstlisting}
*============================================================\\
\textbf{ Parallel 3D phase-field fracture mechanics} \\
*============================================================\\
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 3 -problem damage -model hybrid-phase-field -dirichletconditions 2   

PSD_Solve -np 2  Main.edp -v 0 -ns -nw   
\end{lstlisting}
*============================================================\\
\textbf{ Parallel 2D phase-field fracture mechanics with vectorial FEM } \\
*============================================================\\

\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 2 -problem damage -model hybrid-phase-field -vectorial -dirichletconditions 2   

PSD_Solve -np 2  Main.edp -v 0 -ns -nw   
\end{lstlisting}
*============================================================\\
\textbf{ Parallel 3D phase-field fracture mechanics  with vectorial FEM} \\
*============================================================\\
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 3 -problem damage -model hybrid-phase-field -vectorial -dirichletconditions 2   

PSD_Solve -np 2  Main.edp -v 0 -ns -nw   
\end{lstlisting}
*============================================================\\
\textbf{ Sequential 2D  phase-field fracture mechanics energydecomp }\\
*============================================================\\
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 2 -problem damage -model hybrid-phase-field -sequential -dirichletconditions 2 \
-energydecomp   

PSD_Solve_Seq Main.edp -v 0 -ns -nw   
\end{lstlisting}
*============================================================\\
\textbf{ Sequential 3D phase-field fracture mechanics energydecomp }\\
*============================================================\\
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 3 -problem damage -model hybrid-phase-field -sequential -dirichletconditions 2 \
-energydecomp   

PSD_Solve_Seq Main.edp -v 0 -ns -nw   
\end{lstlisting}
*============================================================\\
\textbf{ Parallel 2D phase-field fracture mechanics energydecomp }\\
*============================================================\\
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 2 -problem damage -model hybrid-phase-field -dirichletconditions 2 -energydecomp   

PSD_Solve -np 2  Main.edp -v 0 -ns -nw   
\end{lstlisting}
*============================================================\\
\textbf{ Parallel 3D phase-field fracture mechanics energydecomp }\\
*============================================================\\
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 3 -problem damage -model hybrid-phase-field -dirichletconditions 2 -energydecomp   

PSD_Solve -np 2  Main.edp -v 0 -ns -nw   
\end{lstlisting}
*============================================================\\
\textbf{ Parallel 2D phase-field fracture mechanics energydecomp \& vectorial}\\
*============================================================\\
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 2 -problem damage -model hybrid-phase-field -vectorial -dirichletconditions 2 \
-energydecomp   

PSD_Solve -np 2  Main.edp -v 0 -ns -nw   
\end{lstlisting}
*============================================================\\
\textbf{ Parallel 3D phase-field fracture mechanics energydecomp }\\
*============================================================\\
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 3 -problem damage -model hybrid-phase-field -vectorial -dirichletconditions 2 \
-energydecomp   

PSD_Solve -np 2  Main.edp -v 0 -ns -nw   
\end{lstlisting}
*============================================================\\
\textbf{ Sequential 2D phase-field fracture mechanics with GFP }\\
*============================================================\\
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 2 -problem damage -model hybrid-phase-field  -dirichletconditions 2 \
-sequential -useGFP   

PSD_Solve Main.edp -v 0 -ns -nw   
\end{lstlisting}
*============================================================\\
\textbf{ Sequential 3D phase-field fracture mechanics with GFP} \\
*============================================================\\
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 3 -problem damage -model hybrid-phase-field  -dirichletconditions 2 \
-sequential -useGFP   

PSD_Solve Main.edp -v 0 -ns -nw   
\end{lstlisting}
*============================================================\\
\textbf{ Parallel 2D phase-field fracture mechanics with GFP} \\
*============================================================\\
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 2 -problem damage -model hybrid-phase-field -dirichletconditions 2 -useGFP   

PSD_Solve -np 2  Main.edp -v 0 -ns -nw   
\end{lstlisting}
*============================================================\\
\textbf{ Parallel 3D phase-field fracture mechanics with GFP }\\
*============================================================\\
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 3 -problem damage -model hybrid-phase-field -dirichletconditions 2 -useGFP   

PSD_Solve -np 2  Main.edp -v 0 -ns -nw   
\end{lstlisting}
*============================================================\\
\textbf{ Parallel 2D phase-field fracture mechanics with GFP \& vectorial} \\
*============================================================\\
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 2 -problem damage -model hybrid-phase-field -vectorial -dirichletconditions 2 -useGFP   

PSD_Solve -np 2  Main.edp -v 0 -ns -nw   
\end{lstlisting}
*============================================================\\
\textbf{ Parallel 3D phase-field fracture mechanics with GFP \& vectorial }\\
*============================================================\\
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 3 -problem damage -model hybrid-phase-field -vectorial -dirichletconditions 2 -useGFP   

PSD_Solve -np 2  Main.edp -v 0 -ns -nw   
\end{lstlisting}
*============================================================\\
 \textbf{Sequential 2D phase-field fracture mechanics with energydecomp \& GFP} \\
*============================================================\\
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 2 -problem damage -model hybrid-phase-field -sequential -dirichletconditions 2 \
-energydecomp -useGFP   

PSD_Solve Main.edp -v 0 -ns -nw   
\end{lstlisting}
*============================================================\\
\textbf{ Sequential 3D phase-field fracture mechanics with energydecomp \& GFP} \\
*============================================================\\
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 3 -problem damage -model hybrid-phase-field -sequential -dirichletconditions 2 \
-energydecomp -useGFP   

PSD_Solve_Seq Main.edp -v 0 -ns -nw   
\end{lstlisting}
*============================================================\\
 \textbf{Parallel 2D phase-field fracture mechanics with energydecomp \& GFP} \\
*============================================================\\
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 2 -problem damage -model hybrid-phase-field -dirichletconditions 2 \
-energydecomp -useGFP  

PSD_Solve -np 2  Main.edp -v 0 -ns -nw   
\end{lstlisting}
*============================================================\\
\textbf{ Parallel 3D phase-field fracture mechanics with energydecomp \& GFP} \\
*============================================================\\
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 3 -problem damage -model hybrid-phase-field -dirichletconditions 2 \
-energydecomp -useGFP   

PSD_Solve -np 2  Main.edp -v 0 -ns -nw   	
\end{lstlisting}
*============================================================\\
 \textbf{Parallel 2D phase-field fracture mechanics with energydecomp, vectorial \& GFP} \\
*============================================================\\
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 2 -problem damage -model hybrid-phase-field -vectorial -dirichletconditions 2 \
-energydecomp -useGFP  

PSD_Solve -np 2  Main.edp -v 0 -ns -nw   
\end{lstlisting}
*============================================================\\
\textbf{ Parallel 3D phase-field fracture mechanics with energydecomp, vectorial \& GFP} \\
*============================================================\\
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 3 -problem damage -model hybrid-phase-field -vectorial -dirichletconditions 2 \
-energydecomp -useGFP   

PSD_Solve -np 2  Main.edp -v 0 -ns -nw   	
\end{lstlisting}
*============================================================\\
 \textbf{Parallel 2D phase-field fracture mechanics with reaction-force, energydecomp, vectorial \& GFP} \\
*============================================================\\
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 2 -problem damage -model hybrid-phase-field -vectorial -dirichletconditions 2 \
-getreactionforce -energydecomp -useGFP  

PSD_Solve -np 2  Main.edp -v 0 -ns -nw   
\end{lstlisting}
*============================================================\\
\textbf{ Parallel 3D phase-field fracture mechanics with reaction-force, energydecomp, vectorial \& GFP} \\
*============================================================\\
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 3 -problem damage -model hybrid-phase-field -vectorial -dirichletconditions 2 \
-getreactionforce -energydecomp -useGFP   

PSD_Solve -np 2  Main.edp -v 0 -ns -nw   	
\end{lstlisting}
*============================================================\\
 \textbf{Parallel 2D phase-field fracture mechanics with live reaction-force plotting, energydecomp, vectorial \& GFP} \\
*============================================================\\
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 2 -problem damage -model hybrid-phase-field -vectorial -dirichletconditions 2 \
-getreactionforce -plotreactionforce -energydecomp -useGFP  

PSD_Solve -np 2  Main.edp -v 0 -ns -nw   
\end{lstlisting}
*============================================================\\
\textbf{ Parallel 3D phase-field fracture mechanics with live reaction-force plotting, energydecomp, vectorial \& GFP} \\
*============================================================\\
\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 3 -problem damage -model hybrid-phase-field -vectorial -dirichletconditions 2 \
-getreactionforce -plotreactionforce -energydecomp -useGFP   

PSD_Solve -np 2  Main.edp -v 0 -ns -nw   	
\end{lstlisting}

\section{General list of examples: Elastodynamics}

*============================================================*\\
\textbf{ Sequential 2D Elastodynamics}  \\                    
*============================================================*\\

\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 2 -problem elastodynamics -sequential -dirichletconditions 1 -tractionconditions 1 

PSD_Solve_Seq Main.edp -v 0 -ns -nw
\end{lstlisting}
*============================================================*\\
\textbf{ Sequential 3D Elastodynamics}  \\                    
*============================================================*\\

\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 3 -problem elastodynamics -sequential -dirichletconditions 1 -tractionconditions 1 

PSD_Solve_Seq Main.edp -v 0 -ns -nw
\end{lstlisting}
*============================================================*\\
\textbf{ Parallel 2D Elastodynamics}   \\                   
*============================================================*\\

\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 2 -problem elastodynamics -dirichletconditions 1 -tractionconditions 1 

PSD_Solve  -np 2 Main.edp -v 0 -ns -nw
\end{lstlisting}
*============================================================*\\
\textbf{ Parallel 3D Elastodynamics } \\                    
*============================================================*\\

\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 3 -problem elastodynamics -dirichletconditions 1 -tractionconditions 1 

PSD_Solve  -np 2 Main.edp -v 0 -ns -nw
\end{lstlisting}

\section{General list of examples: Soildynamics} 

*============================================================*\\
\textbf{ Sequential 2D Soildynamics }    \\                   
*============================================================*\\

\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 2 -problem soildynamics -sequential -dirichletconditions 1  

PSD_Solve_Seq Main.edp -v 0 -ns -nw
\end{lstlisting}
*============================================================*\\
\textbf{ Sequential 3D Soildynamics  }  \\                    
*============================================================*\\

\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 3 -problem soildynamics -sequential -dirichletconditions 1  

PSD_Solve_Seq Main.edp -v 0 -ns -nw
\end{lstlisting}
*============================================================*\\
\textbf{ Parallel 2D Soildynamics  }  \\                    
*============================================================*\\

\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 2 -problem soildynamics -dirichletconditions 1  

PSD_Solve -np 2 Main.edp -v 0 -ns -nw
\end{lstlisting}
*============================================================*\\
\textbf{ Parallel 3D Soildynamics  }     \\                 
*============================================================*\\

\begin{lstlisting}[style=BashInputStyle]
PSD_PreProcess -dimension 3 -problem soildynamics -dirichletconditions 1  

PSD_Solve -np 2 Main.edp -v 0 -ns -nw 
\end{lstlisting}	
\lstset{
  language={PSD},
  basicstyle=\small\ttfamily, % Global Code Style
  captionpos=b, % Position of the Caption (t for top, b for bottom)
  extendedchars=true, % Allows 256 instead of 128 ASCII characters
  tabsize=2, % number of spaces indented when discovering a tab 
  columns=fixed, % make all characters equal width
  keepspaces=true, % does not ignore spaces to fit width, convert tabs to spaces
  showstringspaces=false, % lets spaces in strings appear as real spaces
  breaklines=true, % wrap lines if they don't fit
  frame=trbl, % draw a frame at the top, right, left and bottom of the listing
  frameround=tttt, % make the frame round at all four corners
  framesep=4pt, % quarter circle size of the round corners
  numbers=left, % show line numbers at the left
  numberstyle=\tiny\ttfamily, % style of the line numbers
  commentstyle=\color{eclipseGreen}, % style of comments
  keywordstyle=\color{eclipsePurple}, % style of keywords
  stringstyle=\color{eclipseBlue}, % style of strings
}



%\begin{lstlisting}[language=PSD]
%import math
%import numpy as np
%from lib.analytical import csa
%
%sin2_theta  = np.sin(theta)**2  // THis is  a commen
%+= -= *= /= + - * / ? < > & % == <=
%# += -= *= /= + - * / ? < > & % == <=
%def test(a=100, b=True):
%    <= >= == 2 + 3j * 7e-3
%\end{lstlisting}
